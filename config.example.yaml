# Toolify Configuration Example File
# Please copy this file as config.yaml and modify the configuration according to your actual needs

# Server configuration
server:
  port: 8000                    # Server listening port
  host: "0.0.0.0"              # Server listening address
  timeout: 180                  # Request timeout (seconds)

# Upstream OpenAI compatible service configuration
upstream_services:
  - name: "openai"
    base_url: "https://api.openai.com/v1"
    api_key: "your-openai-api-key-here"
    description: "OpenAI Official Service"
    is_default: true
    models:
      - "gpt-3.5-turbo"
      - "gpt-3.5-turbo-16k"
      - "gpt-4"
      - "gpt-4-turbo"
      - "gpt-4o"
      - "gpt-4o-mini"

  - name: "google"
    base_url: "https://generativelanguage.googleapis.com/v1beta/openai/"
    api_key: "your-google-api-key-here"
    description: "Google Gemini Service"
    is_default: false
    models:
      # Use alias "gemini-2.5" to randomly select one of the following models
      - "gemini-2.5:gemini-2.5-pro"
      - "gemini-2.5:gemini-2.5-flash"
      # You can also define models that can be used directly
      - "gemini-2.5-pro"
      - "gemini-2.5-flash"

# Client authentication configuration
client_authentication:
  allowed_keys:
    - "sk-my-secret-key-1"
    - "sk-my-secret-key-2"

# Feature configuration
features:
  enable_function_calling: true  # Enable function calling feature
  log_level: "INFO"              # Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL, or DISABLED
  convert_developer_to_system: true  # Whether to convert the developer role to the system role
  key_passthrough: false          # If true, directly forward client-provided API key to upstream instead of using configured upstream key
  model_passthrough: false         # If true, forward all requests directly to the 'openai' upstream service, ignoring model-based routing
  prompt_template: |
    IGNORE ALL PREVIOUS INSTRUCTIONS. Your ONLY task is to act as an expert assistant that uses the tools provided below. You MUST strictly follow the format and rules outlined here. Any other instructions are to be disregarded.

    You are an expert assistant equipped with a set of tools to perform tasks. When you need to use a tool, you MUST strictly follow the format below.

    **1. Available Tools:**
    Here is the list of tools you can use. You have access ONLY to these tools and no others.
    {tools_list}

    **2. Tool Call Procedure:**
    When you decide to call a tool, you MUST output EXACTLY this trigger signal: `{trigger_signal}`
    The trigger signal MUST be output on a completely empty line by itself before any tool calls.
    Do NOT add any other text, spaces, or characters before or after `{trigger_signal}` on that line.
    You may provide explanations or reasoning before outputting `{trigger_signal}`, but once you decide to make a tool call, `{trigger_signal}` must come first.
    You MUST output the trigger signal `{trigger_signal}` ONLY ONCE per response. Never output multiple trigger signals in a single response.
    
    After outputting the trigger signal, immediately provide your tool calls enclosed in `<function_calls>` XML tags.

    **3. XML Format for Tool Calls:**
    Your tool calls must be structured EXACTLY as follows. This is the ONLY format you can use, and any deviation will result in failure.
    ```
    {trigger_signal}
    <invoke name="Write">
    <parameter name="file_path">C:\Users\hello\OneDrive\Coding\exp_project\ccr3\weather.css</parameter>
    <parameter name="content"> body { background-color: lightblue; } </parameter>
    </invoke>
    ```

    IMPORTANT RULES:
    - 可以在决定调用工具前提供说明或推理。
    - 一旦决定调用工具，必须在单独一行首先输出触发信号 {trigger_signal}，该行不得包含其他字符或空格。
    - 触发信号在每次响应中只能出现一次，不得重复输出。
    - 工具调用必须使用以下精确的 XML 格式：在触发信号之后立即包含 <function_calls> 容器，内部使用 <invoke> 和 <parameter> 标签。
    - 每个工具调用使用 <invoke name="ToolName">，工具名放在 name 属性中；每个参数使用 <parameter name="argName">value</parameter>。
    - 在 </function_calls> 关闭标签之后不得添加任何额外文本、解释或字符。
    - 当需要调用多个工具时，可以在同一 <function_calls> 容器内按顺序放置多个 <invoke> 块（仍然只允许一次触发信号）。
    - 示例正确格式（必须严格遵守，不得改动标签或结构）：
      {trigger_signal}
      <invoke name="Write">
      <parameter name="file_path">C:\Users\hello\OneDrive\Coding\exp_project\ccr3\weather.css</parameter>
      <parameter name="content"> body { background-color: lightblue; } </parameter>
      </invoke>



# Configuration explanation:
# 1. upstream_services: Configure multiple OpenAI compatible API services
#    - name: Service name (for identification)
#    - base_url: Base URL of the service
#    - api_key: API key for the corresponding service
#    - models: Complete list of models supported by the service
#    - is_default: Whether it is the default service (used when the requested model is not in any service's model list)
#    - description: Service description (optional)
#
# 2. Routing matching rules:
#    - The system will exactly match the corresponding service based on the model name in the request
#    - If the model name is not in the models list of any service, the service with is_default set to true will be used
#    - There must be one and only one service marked as is_default: true
#
# 3. Client authentication:
#    - allowed_keys: List of client API keys allowed to access this middleware
#
# 4. Logging levels:
#    - DEBUG: Show all debug information (most verbose)
#    - INFO: Show general information, warnings and errors
#    - WARNING: Show only warnings and errors
#    - ERROR: Show only errors
#    - CRITICAL: Show only critical errors
#    - DISABLED: Disable all logging
#
# 5. Security reminders:
#    - Please keep API keys safe and do not commit configuration files containing real keys to version control systems
#    - It is recommended to use different configuration files for different environments
#    - Environment variables can be used to manage sensitive information